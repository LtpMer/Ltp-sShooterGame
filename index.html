<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ltp's 2D Shooter Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* General body styling */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #e0e0e0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrollbars */
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Game container styling */
        .game-container {
            background-color: #0d0d1a;
            border: 5px solid #00f0ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.7);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 90%; /* Max width for responsiveness */
            width: 800px; /* Desired width */
            max-height: 90vh; /* Allow container to be scrollable if its content exceeds viewport height */
            overflow-y: auto; /* Enable scrolling for the whole game container if it's too tall */
        }

        /* Canvas styling */
        canvas {
            background-color: #000000;
            display: block;
            border: 3px solid #00c0ff;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 240, 255, 0.5);
            max-width: 100%;
            height: auto;
        }

        /* Info container (score, game over) styling */
        .info-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .info-item {
            font-size: 1.2em;
            color: #00f0ff;
            text-shadow: 0 0 5px #00f0ff;
            flex-shrink: 0; /* Prevent items from shrinking */
            white-space: nowrap; /* Keep text on single line */
            margin: 0 5px; /* Add some margin between items */
        }

        /* Adjust info items for better spacing */
        .info-container > :first-child { margin-left: 0; }
        .info-container > :last-child { margin-right: 0; }


        /* Boss health bar styling */
        #bossHealthContainer {
            width: 100%;
            height: 20px;
            background-color: #333;
            border: 2px solid #ff0077;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
            box-shadow: 0 0 15px rgba(255, 0, 119, 0.7);
        }

        #bossHealthBar {
            height: 100%;
            width: 100%;
            background-color: #ff0077;
            transition: width 0.1s linear;
        }

        /* Game message styling */
        .game-message {
            font-size: 1.5em;
            color: #ff0077;
            text-shadow: 0 0 8px #ff0077;
            text-align: center;
            margin-top: 10px;
            min-height: 1.5em;
        }
        .game-message.small-text {
            font-size: 1em;
        }


        /* Button styling */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        button {
            background-color: #4a0077;
            color: #fff;
            border: 2px solid #ff00ff;
            border-radius: 8px;
            padding: 10px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 0, 255, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            flex-grow: 1;
            max-width: 200px;
        }

        button:hover {
            background-color: #6a0097;
            box-shadow: 0 5px 20px rgba(255, 0, 255, 0.6);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(255, 0, 255, 0.4);
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.7s ease-in-out;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            z-index: 0;
        }

        button:hover::before {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        /* Instructions styling */
        .instructions {
            margin-top: 20px;
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
            max-width: 600px;
        }

        /* Styling for the level map / level selection */
        #levelMapContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0, 240, 255, 0.3);
            flex-wrap: wrap;
            max-width: 100%;
        }

        .level-node {
            width: 35px;
            height: 35px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .level-node:hover {
            transform: scale(1.15);
            background-color: #555;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .level-node.completed {
            background-color: #008800;
            border-color: #00ff00;
            color: #fff;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .level-node.current {
            background-color: #ffaa00;
            border-color: #ffee00;
            color: #000;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.7);
            transform: scale(1.1);
        }

        /* Style for locked levels */
        .level-node.locked {
            background-color: #222;
            border-color: #333;
            color: #666;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .level-node.locked:hover {
            transform: none;
            background-color: #222;
            box-shadow: none;
        }


        /* Shop specific styling */
        .shop-screen { /* Generic class for both shops */
            display: none;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        /* Shop items container itself is now scrollable */
        .shop-items-container { /* Generic class for both shop item containers */
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            /* Increased max-height for better visibility */
            max-height: 600px;
            overflow-y: auto;
            padding-right: 15px;
            box-sizing: border-box;
        }

        /* Customize scrollbar (Webkit browsers) */
        .shop-items-container::-webkit-scrollbar {
            width: 8px;
        }

        .shop-items-container::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 10px;
        }

        .shop-items-container::-webkit-scrollbar-thumb {
            background: #00f0ff;
            border-radius: 10px;
            border: 2px solid #1a1a2e;
        }

        .shop-items-container::-webkit-scrollbar-thumb:hover {
            background: #00c0ff;
        }


        .shop-item {
            background-color: #1c1c3a;
            border: 2px solid #00c0ff;
            border-radius: 10px;
            padding: 15px;
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 0 15px rgba(0, 192, 255, 0.5);
            text-align: left;
            margin: 0 auto;
        }

        .shop-item h3 {
            margin: 0;
            color: #ffdd00;
            font-size: 1.1em;
        }

        .shop-item p {
            margin: 0;
            font-size: 0.8em;
            color: #b0b0b0;
        }

        .shop-item .cost {
            font-size: 1em;
            color: #00ff77;
            font-weight: bold;
        }

        .shop-item.epsilon .cost { /* Specific style for E$ costs */
            color: #ff00ff; /* Purple/pink for E$ */
        }

        .shop-item .equip-status {
            font-size: 0.9em;
            color: #00ff77; /* Green for equipped */
            font-weight: bold;
            text-align: right;
        }

        .shop-item .equip-status.not-equipped {
            color: #aaa; /* Gray for not equipped */
        }

        .shop-item button {
            width: 100%;
            margin-top: 10px;
            padding: 8px 15px;
            font-size: 0.9em;
        }
        .shop-item button.equip-button {
            background-color: #00774a;
            border-color: #00ff77;
        }
        .shop-item button.equip-button:hover {
            background-color: #00976a;
            box-shadow: 0 5px 20px rgba(0, 255, 119, 0.6);
        }
        .shop-item button.equip-button:disabled {
            background-color: #555;
            border-color: #777;
            cursor: default;
            box-shadow: none;
            transform: none;
            opacity: 0.7;
        }


        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
                gap: 10px;
                width: 95%;
            }

            canvas {
                border-width: 2px;
            }

            .info-item {
                font-size: 1em;
            }

            .game-message {
                font-size: 1.2em;
            }

            button {
                padding: 8px 15px;
                font-size: 0.9em;
                max-width: 100%;
            }

            .instructions {
                font-size: 0.8em;
            }

            #levelMapContainer {
                gap: 5px;
                padding: 5px;
            }

            .level-node {
                width: 30px;
                height: 30px;
                font-size: 0.8em;
            }

            .shop-item {
                width: 95%;
            }
        }

        /* Mobile Controls Styling */
        #mobileControls {
            /* display: none; */ /* Will be managed by JS based on screen size */
            width: 100%;
            display: flex; /* Always use flex for layout */
            justify-content: space-around;
            padding: 15px 0;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-top: 15px;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
            flex-wrap: wrap; /* Allow wrapping on very small screens */
            gap: 10px; /* Space between buttons */
        }

        #mobileControls button {
            flex: 1 1 30%; /* Allow buttons to grow, but min 30% width */
            min-width: 100px; /* Minimum width for touch target */
            padding: 15px 10px;
            font-size: 1.1em;
            border-radius: 10px;
            -webkit-user-select: none; /* Prevent text selection on mobile */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }

        #mobileControls #shootBtn {
            background-color: #77004a; /* Different color for shoot */
            border-color: #ff0077;
        }
        #mobileControls #shootBtn:hover {
            background-color: #97006a;
            box-shadow: 0 5px 20px rgba(255, 0, 119, 0.6);
        }

        /* Settings and Reset Panel Styling (reusing shop-screen) */
        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 80%;
            max-width: 400px;
            background-color: #1c1c3a;
            border: 2px solid #00c0ff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 192, 255, 0.5);
            margin: 0 auto;
            gap: 10px;
        }
        .settings-option p {
            margin: 0;
            font-size: 1em;
            color: #ffdd00;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .settings-option button {
            width: auto;
            flex-grow: 0;
            padding: 8px 15px;
            margin-left: 10px; /* Space between label and button */
        }
        .settings-option button.active-setting {
            background-color: #00774a;
            border-color: #00ff77;
        }
        .settings-option button.inactive-setting {
            background-color: #774a00;
            border-color: #ff7700;
        }
        .settings-option button:hover.active-setting {
            background-color: #00976a;
        }
        .settings-option button:hover.inactive-setting {
            background-color: #976a00;
        }

        /* Volume Slider Specific Styling */
        .volume-slider-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 80%;
            max-width: 400px;
            background-color: #1c1c3a;
            border: 2px solid #00c0ff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 192, 255, 0.5);
            margin: 0 auto;
            gap: 10px;
        }

        .volume-slider-container label {
            font-size: 1em;
            color: #ffdd00;
            white-space: nowrap;
        }

        .volume-slider-container input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            background: #333;
            outline: none;
            height: 8px;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: inset 0 0 5px rgba(0, 240, 255, 0.3);
        }

        .volume-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00f0ff;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.7);
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .volume-slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00f0ff;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.7);
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .volume-slider-container input[type="range"]::-webkit-slider-thumb:hover {
            background: #00c0ff;
            box-shadow: 0 0 15px rgba(0, 240, 255, 1);
        }

        .volume-slider-container input[type="range"]::-moz-range-thumb:hover {
            background: #00c0ff;
            box-shadow: 0 0 15px rgba(0, 240, 255, 1);
        }
    </style>
    <!-- Tone.js library for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>
    <div class="game-container">
        <div class="info-container">
            <div id="playerPoundsDisplay" class="info-item">P$: 0</div>
            <div id="playerEpsilonDollarsDisplay" class="info-item">E$: 0</div>
            <div id="healthDisplay" class="info-item">Health: 3</div>
            <div id="levelDisplay" class="info-item" style="display: none;">Level: 1</div>
        </div>
        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
        </div>
        <div id="levelMapContainer" style="display: none;"></div>
        <canvas id="gameCanvas"></canvas>
        <!-- Mobile Controls -->
        <div id="mobileControls" style="display: none;">
            <button id="leftBtn">LEFT</button>
            <button id="shootBtn">SHOOT</button>
            <button id="rightBtn">RIGHT</button>
        </div>
        <div id="gameMessage" class="game-message">Loading Game...</div>

        <!-- P$ Shop Screen -->
        <div id="pShopScreen" class="shop-screen">
            <h2 style="color: #00f0ff; text-shadow: 0 0 5px #00f0ff;">P$ Shop</h2>
            <div id="pShopItemsContainer" class="shop-items-container">
            </div>
            <button id="backToMenuFromPShopBtn">Back to Main Menu</button>
        </div>

        <!-- E$ Shop Screen -->
        <div id="eShopScreen" class="shop-screen">
            <h2 style="color: #ff00ff; text-shadow: 0 0 5px #ff00ff;">E$ Shop (Permanent Upgrades)</h2>
            <p id="equippedBulletModeDisplay" class="info-item" style="margin-top: 10px; color: #00f0ff;">Equipped Bullet: Normal</p>
            <div id="eShopItemsContainer" class="shop-items-container">
            </div>
            <button id="backToMenuFromEShopBtn">Back to Main Menu</button>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="shop-screen">
            <h2 style="color: #00f0ff; text-shadow: 0 0 5px #00f0ff;">Settings</h2>
            <div class="volume-slider-container">
                <label for="volumeSlider">Volume:</label>
                <input type="range" id="volumeSlider" min="-40" max="0" step="1">
            </div>
            <div class="settings-option">
                <p>Volume Toggle:</p>
                <button id="toggleVolumeBtn"></button>
            </div>
            <div class="settings-option">
                <p>Particles:</p>
                <button id="toggleParticlesBtn"></button>
            </div>
            <button id="resetGameDataBtn">Reset Game Data</button>
            <button id="backToMenuFromSettingsBtn">Back to Main Menu</button>
        </div>

        <!-- Reset Confirmation Panel -->
        <div id="resetConfirmationPanel" class="shop-screen">
            <h2 style="color: #ff0077; text-shadow: 0 0 5px #ff0077;">Confirm Reset</h2>
            <p style="color: #ccc; font-size: 0.9em; text-align: center;">Choose a reset option. This cannot be undone.</p>
            <div class="button-group" style="flex-direction: column; width: 100%;">
                <button id="confirmResetAllDataBtn" style="background-color: #a00; border-color: #f00;">Reset All Game Data</button>
                <button id="confirmResetLevelProgressBtn" style="background-color: #a40; border-color: #f80;">Reset Level Progress Only</button>
                <button id="confirmResetUpgradesBtn" style="background-color: #04a; border-color: #08f;">Reset Upgrades Only</button>
                <button id="cancelResetBtn">Cancel</button>
            </div>
        </div>


        <!-- Main Menu Buttons -->
        <div id="mainMenuButtons" class="button-group">
            <button id="levelModeBtn">Level Mode</button>
            <button id="endlessModeBtn">Endless Mode</button>
            <button id="pShopBtn">P$ Shop</button>
            <button id="eShopBtn">E$ Shop</button>
            <button id="settingsBtn">Settings</button>
        </div>

        <!-- In-Game Buttons -->
        <div id="inGameButtons" class="button-group" style="display: none;">
            <button id="nextLevelBtn" style="display: none;">Next Level</button>
            <button id="resetGameBtn" style="display: none;">Play Again</button>
            <button id="returnToMenuBtn" style="display: none;">Main Menu</button>
        </div>
    </div>
    <div id="instructionsText" class="instructions">
        <p>Instructions:</p>
        <p>Use LEFT and RIGHT arrow keys to move.</p>
        <p>Press SPACEBAR to shoot.</p>
        <p>Destroy enemies to earn P$. Catch falling bonuses!</p>
        <p>On mobile, use the on-screen buttons to control movement and shooting.</p>
    </div>

    <script type="module">
        // --- Game Configuration Data ---
        let enemyDropBonusChance = 0.3; // Made mutable for upgrades

        const pShopItems = [
            {
                id: 'player_speed_1',
                name: "Speed Boost I",
                description: "Increase player movement speed by 1.",
                cost: 100,
                effect: () => { player.baseSpeed += 1; },
                maxPurchases: 3,
                currentPurchases: 0,
                initialValue: 0 // Store initial purchase count for reset
            },
            {
                id: 'player_speed_2',
                name: "Speed Boost II",
                description: "Increase player movement speed by 2.",
                cost: 300,
                effect: () => { player.baseSpeed += 2; },
                maxPurchases: 1,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'max_health_upgrade',
                name: "Max Health Upgrade",
                description: "Increase max player health by 1.",
                cost: 200,
                effect: () => { playerMaxHealth += 1; playerHealth = playerMaxHealth; },
                maxPurchases: 2,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'bullet_damage_upgrade',
                name: "Bullet Damage +1",
                description: "Increase your bullet damage by 1.",
                cost: 150,
                effect: () => { player.baseBulletDamage += 1; },
                maxPurchases: 3,
                currentPurchases: 0,
                initialValue: 0
            },
            // NEW P$ SHOP UPGRADES
            {
                id: 'health_regen',
                name: "Health Regeneration",
                description: "Slowly regenerate health over time. (Stacks)",
                cost: 250,
                effect: () => { player.healthRegenAmount += 0.005; },
                maxPurchases: 5,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'bullet_speed_boost',
                name: "Bullet Speed Boost",
                description: "Increase your bullet travel speed. (Stacks)",
                cost: 180,
                effect: () => { player.bulletSpeedMultiplier += 0.1; },
                maxPurchases: 5,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'bonus_luck',
                name: "Bonus Luck",
                description: "Increases chance of enemies dropping bonuses. (Stacks)",
                cost: 120,
                effect: () => { enemyDropBonusChance += 0.05; }, // Directly modifies the global variable
                maxPurchases: 3,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'pounds_magnet',
                name: "Pound Magnet",
                description: "Increase Pounds gained from enemies. (Stacks)",
                cost: 100,
                effect: () => { player.poundsMultiplier += 0.05; },
                maxPurchases: 5,
                currentPurchases: 0,
                initialValue: 0
            }
        ];

        const eShopItems = [
            {
                id: 'permanent_rapid_fire',
                name: "Permanent Rapid Fire",
                description: "Permanently reduces your base bullet cooldown by 50ms.",
                cost: 25,
                currency: 'E$',
                effect: () => {
                    player.baseShootCooldown = Math.max(100, player.baseShootCooldown - 50);
                },
                maxPurchases: 5,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'piercing_shot_1',
                name: "Piercing Shot I",
                description: "Your bullets pierce through 1 additional enemy. (Stacks with II)",
                cost: 15,
                currency: 'E$',
                effect: () => { player.hasPiercingShotLevel = Math.max(player.hasPiercingShotLevel, 1); },
                maxPurchases: 1,
                currentPurchases: 0,
                initialValue: 0
            },
            {
                id: 'piercing_shot_2',
                name: "Piercing Shot II",
                description: "Your bullets pierce through 2 additional enemies. (Requires Piercing Shot I)",
                cost: 25,
                currency: 'E$',
                effect: () => { player.hasPiercingShotLevel = Math.max(player.hasPiercingShotLevel, 2); },
                maxPurchases: 1,
                currentPurchases: 0,
                requires: [{ id: 'piercing_shot_1', purchased: 1 }],
                initialValue: 0
            },
            {
                id: 'exploding_bullets',
                name: "Exploding Bullets",
                description: "Destroyed enemies leave behind a yellow orb that damages foes.",
                cost: 40,
                currency: 'E$',
                effect: () => { /* Effect applied on equip */ },
                maxPurchases: 1,
                currentPurchases: 0,
                isEquippable: true,
                equippedEffect: () => { player.hasExplodingBullets = true; },
                unequippedEffect: () => { player.hasExplodingBullets = false; },
                initialValue: 0
            },
            {
                id: 'homing_bullets',
                name: "Homing Bullets",
                description: "Your bullets slightly curve towards the nearest enemy (mild homing). Equip to activate.",
                cost: 60,
                currency: 'E$',
                effect: () => { /* Effect applied on equip */ },
                maxPurchases: 1,
                currentPurchases: 0,
                isEquippable: true,
                equippedEffect: () => { player.hasHomingBullets = true; },
                unequippedEffect: () => { player.hasHomingBullets = false; },
                initialValue: 0
            },
            {
                id: 'beam_shot',
                name: "Beam Shot",
                description: "Fires a powerful vertical blue energy beam. Equip to activate.",
                cost: 125, // Updated cost
                currency: 'E$',
                effect: () => { /* Effect applied on equip */ },
                maxPurchases: 1,
                currentPurchases: 0,
                isEquippable: true,
                equippedEffect: () => { player.hasBeamShot = true; },
                unequippedEffect: () => { player.hasBeamShot = false; },
                initialValue: 0
            },
            // NEW E$ SHOP UPGRADES
            {
                id: 'enemy_slow',
                name: "Enemy Slow",
                description: "Equip to slow all enemies by 20%.",
                cost: 75,
                currency: 'E$',
                effect: () => { /* Effect applied on equip */ },
                maxPurchases: 1,
                currentPurchases: 0,
                isEquippable: true,
                equippedEffect: () => { player.enemySlowActive = true; },
                unequippedEffect: () => { player.enemySlowActive = false; },
                initialValue: 0
            },
            {
                id: 'shield',
                name: "Energy Shield",
                description: "Equip to gain a shield that absorbs one hit every 10 seconds.",
                cost: 100,
                currency: 'E$',
                effect: () => { /* Effect applied on equip */ },
                maxPurchases: 1,
                currentPurchases: 0,
                isEquippable: true,
                equippedEffect: () => { player.hasShield = true; player.shieldActive = true; player.lastShieldUsedTime = 0; },
                unequippedEffect: () => { player.hasShield = false; player.shieldActive = false; },
                initialValue: 0
            },
            {
                id: 'explosive_boost',
                name: "Explosive Boost",
                description: "Increase damage of exploding bullets by 50%. (Requires Exploding Bullets)",
                cost: 30,
                currency: 'E$',
                effect: () => { player.explosionDamageMultiplier += 0.5; },
                maxPurchases: 3,
                currentPurchases: 0,
                requires: [{ id: 'exploding_bullets', purchased: 1 }],
                initialValue: 0
            },
            {
                id: 'crit_chance',
                name: "Critical Chance",
                description: "Your bullets have a 2% chance to deal double damage. (Stacks)",
                cost: 50,
                currency: 'E$',
                effect: () => { player.critChance += 0.02; },
                maxPurchases: 5,
                currentPurchases: 0,
                initialValue: 0
            }
        ];

        const levels = [];

        function addLevels(start, end, config) {
            for (let i = start; i <= end; i++) {
                levels.push({
                    name: `Level ${i}`,
                    enemyCount: config.baseEnemyCount + (i - start) * config.enemyCountIncrease,
                    enemySpeed: config.baseEnemySpeed + (i - start) * config.enemySpeedIncrease,
                    enemySpawnInterval: Math.max(config.minSpawnInterval, config.baseSpawnInterval - (i - start) * config.spawnIntervalDecrease),
                    heavyEnemyChance: config.heavyEnemyChance,
                    shooterEnemyChance: config.shooterEnemyChance,
                    dodgerEnemyChance: config.dodgerEnemyChance || 0,
                    armoredEnemyChance: config.armoredEnemyChance || 0,
                    bossLevel: false,
                    message: `Level ${i}: ${config.tierName}`
                });
            }
        }

        // Original Levels
        addLevels(1, 5, {
            tierName: "Easy",
            baseEnemyCount: 5,
            enemyCountIncrease: 2,
            baseEnemySpeed: 0.5,
            enemySpeedIncrease: 0.1,
            baseSpawnInterval: 2500,
            spawnIntervalDecrease: 200,
            minSpawnInterval: 1500,
            heavyEnemyChance: 0.05,
            shooterEnemyChance: 0.02,
            dodgerEnemyChance: 0.0,
            armoredEnemyChance: 0.0
        });

        addLevels(6, 9, {
            tierName: "Medium",
            baseEnemyCount: 15,
            enemyCountIncrease: 3,
            baseEnemySpeed: 0.9,
            enemySpeedIncrease: 0.15,
            baseSpawnInterval: 1500,
            spawnIntervalDecrease: 150,
            minSpawnInterval: 800,
            heavyEnemyChance: 0.2,
            shooterEnemyChance: 0.1,
            dodgerEnemyChance: 0.05,
            armoredEnemyChance: 0.02
        });
        levels.push({
            name: "The Guardian",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 10: Confront The Guardian!",
            bossSpecifics: {
                health: 500, // Buffed
                movementSpeed: 2.0, // Buffed
                spreadShotInterval: 1500, // Buffed
                trackingShotInterval: 3000, // Buffed
                bulletSpeed: 4.0, // Buffed
                minionsToSummon: 0,
                minionSummonThresholds: []
            }
        });

        addLevels(11, 19, {
            tierName: "Medium-Hard",
            baseEnemyCount: 25,
            enemyCountIncrease: 4,
            baseEnemySpeed: 1.2,
            enemySpeedIncrease: 0.1,
            baseSpawnInterval: 1000,
            spawnIntervalDecrease: 100,
            minSpawnInterval: 500,
            heavyEnemyChance: 0.35,
            shooterEnemyChance: 0.2,
            dodgerEnemyChance: 0.1,
            armoredEnemyChance: 0.05
        });
        levels.push({
            name: "The Sentinel",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 20: The Sentinel Awaits!",
            bossSpecifics: {
                health: 900, // Buffed
                movementSpeed: 2.8, // Buffed
                spreadShotInterval: 900, // Buffed
                trackingShotInterval: 1800, // Buffed
                bulletSpeed: 5.0, // Buffed
                minionsToSummon: 4, // Buffed
                minionSummonThresholds: [0.7, 0.4] // Added threshold
            }
        });

        addLevels(21, 29, {
            tierName: "Hard",
            baseEnemyCount: 35,
            enemyCountIncrease: 5,
            baseEnemySpeed: 1.5,
            enemySpeedIncrease: 0.1,
            baseSpawnInterval: 700,
            spawnIntervalDecrease: 50,
            minSpawnInterval: 300,
            heavyEnemyChance: 0.5,
            shooterEnemyChance: 0.35,
            dodgerEnemyChance: 0.15,
            armoredEnemyChance: 0.1
        });
        levels.push({
            name: "The Annihilator",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 30: CONFRONT THE ANNIHILATOR!",
            bossSpecifics: {
                health: 1500, // Buffed
                movementSpeed: 3.5, // Buffed
                spreadShotInterval: 700, // Buffed
                trackingShotInterval: 1400, // Buffed
                bulletSpeed: 5.5, // Buffed
                minionsToSummon: 5, // Buffed
                minionSummonThresholds: [0.9, 0.7, 0.4, 0.2] // More thresholds
            }
        });

        // NEW LEVELS (31-60)
        addLevels(31, 39, {
            tierName: "Very Hard",
            baseEnemyCount: 45,
            enemyCountIncrease: 6,
            baseEnemySpeed: 1.8,
            enemySpeedIncrease: 0.1,
            baseSpawnInterval: 600,
            spawnIntervalDecrease: 40,
            minSpawnInterval: 250,
            heavyEnemyChance: 0.6,
            shooterEnemyChance: 0.4,
            dodgerEnemyChance: 0.2,
            armoredEnemyChance: 0.15
        });
        levels.push({
            name: "The Obliterator",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 40: The Obliterator Descends!",
            bossSpecifics: {
                health: 2000,
                movementSpeed: 4.0,
                spreadShotInterval: 600,
                trackingShotInterval: 1200,
                bulletSpeed: 6.0,
                minionsToSummon: 6,
                minionSummonThresholds: [0.95, 0.8, 0.6, 0.4, 0.2]
            }
        });

        addLevels(41, 49, {
            tierName: "Extreme",
            baseEnemyCount: 55,
            enemyCountIncrease: 7,
            baseEnemySpeed: 2.2,
            enemySpeedIncrease: 0.15,
            baseSpawnInterval: 500,
            spawnIntervalDecrease: 30,
            minSpawnInterval: 200,
            heavyEnemyChance: 0.7,
            shooterEnemyChance: 0.5,
            dodgerEnemyChance: 0.3,
            armoredEnemyChance: 0.2
        });
        levels.push({
            name: "The Tyrant",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 50: Face The Tyrant!",
            bossSpecifics: {
                health: 3000,
                movementSpeed: 4.5,
                spreadShotInterval: 500,
                trackingShotInterval: 1000,
                bulletSpeed: 6.5,
                minionsToSummon: 7,
                minionSummonThresholds: [0.95, 0.85, 0.7, 0.55, 0.4, 0.25, 0.1]
            }
        });

        addLevels(51, 59, {
            tierName: "Ultimate",
            baseEnemyCount: 65,
            enemyCountIncrease: 8,
            baseEnemySpeed: 2.5,
            enemySpeedIncrease: 0.2,
            baseSpawnInterval: 400,
            spawnIntervalDecrease: 20,
            minSpawnInterval: 150,
            heavyEnemyChance: 0.8,
            shooterEnemyChance: 0.6,
            dodgerEnemyChance: 0.4,
            armoredEnemyChance: 0.25
        });
        levels.push({
            name: "The Omega",
            enemyCount: 0,
            enemySpeed: 0,
            enemySpawnInterval: 9999999,
            heavyEnemyChance: 0,
            shooterEnemyChance: 0,
            dodgerEnemyChance: 0,
            armoredEnemyChance: 0,
            bossLevel: true,
            message: "Level 60: THE FINAL BOSS - THE OMEGA!",
            bossSpecifics: {
                health: 5000,
                movementSpeed: 5.0,
                spreadShotInterval: 400,
                trackingShotInterval: 800,
                bulletSpeed: 7.0,
                minionsToSummon: 8,
                minionSummonThresholds: [0.98, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]
            }
        });

        // --- End Game Configuration ---

        // --- DOM Element References ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 400;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const playerPoundsDisplay = document.getElementById('playerPoundsDisplay');
        const playerEpsilonDollarsDisplay = document.getElementById('playerEpsilonDollarsDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const bossHealthContainer = document.getElementById('bossHealthContainer');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const gameMessageElement = document.getElementById('gameMessage');
        const mobileControls = document.getElementById('mobileControls');

        // Buttons
        const levelModeBtn = document.getElementById('levelModeBtn');
        const endlessModeBtn = document.getElementById('endlessModeBtn');
        const pShopBtn = document.getElementById('pShopBtn');
        const eShopBtn = document.getElementById('eShopBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const backToMenuFromPShopBtn = document.getElementById('backToMenuFromPShopBtn');
        const backToMenuFromEShopBtn = document.getElementById('backToMenuFromEShopBtn');
        const backToMenuFromSettingsBtn = document.getElementById('backToMenuFromSettingsBtn');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const returnToMenuBtn = document.getElementById('returnToMenuBtn');
        const mainMenuButtons = document.getElementById('mainMenuButtons');
        const inGameButtons = document.getElementById('inGameButtons');

        // Shop containers
        const pShopScreen = document.getElementById('pShopScreen');
        const eShopScreen = document.getElementById('eShopScreen');
        const settingsScreen = document.getElementById('settingsScreen');
        const resetConfirmationPanel = document.getElementById('resetConfirmationPanel');
        const pShopItemsContainer = document.getElementById('pShopItemsContainer');
        const eShopItemsContainer = document.getElementById('eShopItemsContainer');
        const equippedBulletModeDisplay = document.getElementById('equippedBulletModeDisplay');
        const levelMapContainer = document.getElementById('levelMapContainer');

        // Settings elements
        const volumeSlider = document.getElementById('volumeSlider');
        const toggleVolumeBtn = document.getElementById('toggleVolumeBtn');
        const toggleParticlesBtn = document.getElementById('toggleParticlesBtn');
        const resetGameDataBtn = document.getElementById('resetGameDataBtn');
        const confirmResetAllDataBtn = document.getElementById('confirmResetAllDataBtn');
        const confirmResetLevelProgressBtn = document.getElementById('confirmResetLevelProgressBtn');
        const confirmResetUpgradesBtn = document.getElementById('confirmResetUpgradesBtn');
        const cancelResetBtn = document.getElementById('cancelResetBtn');

        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const shootBtn = document.getElementById('shootBtn');

        // --- Game State Variables ---
        let playerPounds = 0;
        let playerEpsilonDollars = 0;
        let initialPlayerMaxHealth = 3;
        let playerHealth = initialPlayerMaxHealth;
        let playerMaxHealth = initialPlayerMaxHealth;
        let currentLevelIndex = 0;
        let completedLevels = new Set();
        let gameMode = null; // 'level' or 'endless'
        let uiState = 'mainMenu'; // 'mainMenu', 'levelSelect', 'inGame', 'levelComplete', 'gameOver', 'pShop', 'eShop', 'settings', 'resetConfirm'
        let gameMessage = '';
        let showGameMessage = false;
        let isGameMessageSmall = false;

        let gameSettings = {
            volume: -10, // in dB
            particles: true
        };
        let equippedBulletMode = 'normal';

        const player = {
            width: 40,
            height: 20,
            x: CANVAS_WIDTH / 2 - 20,
            y: CANVAS_HEIGHT - 40,
            baseSpeed: 5,
            initialBaseSpeed: 5, // Store initial values for full reset
            baseBulletDamage: 1,
            initialBaseBulletDamage: 1,
            baseShootCooldown: 500,
            initialBaseShootCooldown: 500,
            color: '#00ff77',
            hasBeamShot: false,
            hasExplodingBullets: false,
            hasHomingBullets: false,
            hasPiercingShotLevel: 0,
            initialPiercingShotLevel: 0,
            
            // NEW PLAYER UPGRADE STATS
            healthRegenAmount: 0, // Health regenerated per frame/second
            bulletSpeedMultiplier: 1.0, // Multiplier for bullet speed
            poundsMultiplier: 1.0, // Multiplier for pounds gained
            enemySlowActive: false, // Is enemy slow active (from equippable)
            hasShield: false, // Does player have the shield upgrade
            shieldActive: false, // Is the shield currently active
            shieldCooldown: 10000, // 10 seconds cooldown for shield
            lastShieldUsedTime: 0, // Timestamp of last shield use
            explosionDamageMultiplier: 1.0, // Multiplier for explosion orb damage
            critChance: 0 // Chance to deal critical hit (0.0 - 1.0)
        };

        const bullets = [];
        const enemies = [];
        const enemyBullets = [];
        const bonuses = [];
        const particles = [];
        const explosionOrbs = [];

        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false
        };

        const boss = {
            exists: false,
            health: 0,
            maxHealth: 0,
            x: 0,
            y: 50,
            width: 80,
            height: 80,
            color: '#8800ff',
            speed: 2,
            direction: 1,
            shootCooldownSpread: 1500,
            shootCooldownTracking: 3000,
            lastShotTimeSpread: 0,
            lastShotTimeTracking: 0,
            minionsToSummon: 0,
            minionSummonThresholds: [],
            summonedMinionsAtThreshold: [],
            bulletSpeedOverride: 3
        };

        // Game loop related
        let animationId = null;
        let epsilonDollarIntervalId = null;
        let lastEnemySpawnTime = 0;
        let canShoot = true;
        let multiShotCount = 1;
        let multiShotEffectEndTime = 0;
        let cooldownEffectEndTime = 0;
        let lastBossSpawnAttemptTime = 0;
        let levelCompletionHandled = false;

        // Tone.js Synths
        let playerShootSynth;
        let hitSynth;
        let explosionSynth;
        let beamSynth;
        let lastHitSoundTime = 0;
        const hitSoundCooldown = 50; // ms between hit sounds

        const enemyTypes = {
            NORMAL: { health: 1, color: '#ff0077', canShoot: false, value: 10, speed: 1.0 },
            HEAVY: { health: 2, color: '#cc00cc', canShoot: false, value: 20, speed: 0.7 },
            SHOOTER: { health: 1, color: '#ff5500', canShoot: true, shootCooldown: 2000, value: 15, speed: 1.2 },
            DODGER: { health: 1, color: '#00ccff', canShoot: false, value: 30, speed: 3.0 },
            ARMORED: { health: 5, color: '#888888', canShoot: false, value: 50, speed: 0.4 },
            BOSS_MINION: { health: 2, color: '#ff00ff', canShoot: true, shootCooldown: 1500, speed: 1.5, value: 25 }
        };

        const bonusTypes = {
            HEALTH: { color: '#00ff00', label: '+' },
            COOLDOWN: { color: '#00ffff', label: 'C' },
            MULTISHOT: { color: '#ff8800', label: 'M' }
        };

        const SECRET_CODE_PREFIX = 'E$m-+99';


        // --- Utility Functions ---
        function showMessage(message, isSmall = false, duration = 1500) {
            gameMessage = message;
            gameMessageElement.textContent = message;
            if (isSmall) {
                gameMessageElement.classList.add('small-text');
            } else {
                gameMessageElement.classList.remove('small-text');
            }
            showGameMessage = true;
            clearTimeout(gameMessageElement.dataset.timeoutId);
            gameMessageElement.dataset.timeoutId = setTimeout(() => {
                showGameMessage = false;
                gameMessageElement.textContent = '';
            }, duration);
        }

        function updateUI() {
            playerPoundsDisplay.textContent = `P$: ${playerPounds}`;
            playerEpsilonDollarsDisplay.textContent = `E$: ${playerEpsilonDollars}`;
            healthDisplay.textContent = `Health: ${playerHealth}/${playerMaxHealth}`; // Display max health too
            levelDisplay.textContent = `Level: ${currentLevelIndex + 1}`;

            if (boss.exists) {
                bossHealthContainer.style.display = 'block';
                bossHealthBar.style.width = `${(boss.health / boss.maxHealth) * 100}%`;
            } else {
                bossHealthContainer.style.display = 'none';
            }

            // Update mobile controls visibility
            checkAndSetMobileControlsVisibility();

            // Update settings UI
            updateSettingsDisplay();

            // Update equipped bullet mode display
            const currentEquippedItem = eShopItems.find(item => item.id === equippedBulletMode && item.isEquippable);
            equippedBulletModeDisplay.textContent = `Equipped Bullet: ${currentEquippedItem?.name || 'Normal'}`;
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // --- Core Game Logic Functions ---

        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw shield visual if active
            if (player.hasShield && player.shieldActive) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, Math.max(player.width, player.height) / 2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function updatePlayer() {
            const currentEffectiveSpeed = player.baseSpeed;

            if (keys.ArrowLeft && player.x > 0) {
                player.x -= currentEffectiveSpeed;
            }
            if (keys.ArrowRight && player.x < CANVAS_WIDTH - player.width) {
                player.x += currentEffectiveSpeed;
            }

            let currentEffectiveShootCooldown = player.baseShootCooldown;
            if (Date.now() < cooldownEffectEndTime) {
                currentEffectiveShootCooldown = Math.min(currentEffectiveShootCooldown, 150); // ReducedCooldown
            }

            if (keys.Space && canShoot) {
                shootPlayerBullet();
                canShoot = false;
                setTimeout(() => {
                    canShoot = true;
                }, currentEffectiveShootCooldown);
            }

            // Apply health regeneration
            if (player.healthRegenAmount > 0 && playerHealth < playerMaxHealth) {
                playerHealth = Math.min(playerHealth + player.healthRegenAmount, playerMaxHealth);
            }
        }

        function shootPlayerBullet() {
            if (gameSettings.volume > -39) playerShootSynth.triggerAttackRelease("C4", "8n");

            let bulletDamage = player.baseBulletDamage;
            // Apply critical hit chance
            if (player.critChance > 0 && Math.random() < player.critChance) {
                bulletDamage *= 2;
                showMessage('CRITICAL HIT!', true, 500);
            }

            const bulletWidth = 4;
            const bulletHeight = 10;
            const bulletColor = '#ffdd00';
            const baseBulletX = player.x + player.width / 2 - bulletWidth / 2;
            const bulletDetails = {
                width: bulletWidth,
                height: bulletHeight,
                color: bulletColor,
                damage: bulletDamage,
                piercedCount: player.hasPiercingShotLevel
            };

            if (equippedBulletMode === 'beam_shot') {
                if (gameSettings.volume > -39) beamSynth.triggerAttackRelease("C3", "0.5");
                bullets.push({
                    x: player.x + player.width / 2 - 10,
                    y: player.y - CANVAS_HEIGHT,
                    width: 20,
                    height: CANVAS_HEIGHT,
                    color: 'rgba(0, 150, 255, 0.7)',
                    damage: bulletDamage * 20,
                    isBeam: true,
                    lifetime: 10
                });
                if (gameSettings.particles) {
                    for (let y = player.y; y > 0; y -= 10) {
                        createExplosionParticles(player.x + player.width / 2, y, '#0096FF', 2);
                    }
                }
                return;
            }

            if (multiShotCount === 1) {
                bullets.push({ x: baseBulletX, y: player.y - bulletHeight, ...bulletDetails });
            } else if (multiShotCount === 2) {
                bullets.push({ x: baseBulletX - 8, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX + 8, y: player.y - bulletHeight, ...bulletDetails });
            } else if (multiShotCount === 3) {
                bullets.push({ x: baseBulletX, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX - 15, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX + 15, y: player.y - bulletHeight, ...bulletDetails });
            } else if (multiShotCount === 4) {
                bullets.push({ x: baseBulletX - 20, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX - 7, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX + 7, y: player.y - bulletHeight, ...bulletDetails });
                bullets.push({ x: baseBulletX + 20, y: player.y - bulletHeight, ...bulletDetails });
            }
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function updateBullets() {
            const baseBulletSpeed = 7;
            const currentBulletSpeed = baseBulletSpeed * player.bulletSpeedMultiplier;

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                if (bullet.isBeam) {
                    bullet.lifetime--;
                    if (bullet.lifetime <= 0) {
                        bullets.splice(i, 1);
                    }
                } else {
                    if (player.hasHomingBullets && enemies.length > 0) {
                        let closestEnemy = null;
                        let minDistSq = Infinity;

                        for (const enemy of enemies) {
                            const dx = (enemy.x + enemy.width / 2) - (bullet.x + bullet.width / 2);
                            const dy = (enemy.y + enemy.height / 2) - (bullet.y + bullet.height / 2);
                            const distSq = dx * dx + dy * dy;
                            if (distSq < minDistSq) {
                                minDistSq = distSq;
                                closestEnemy = enemy;
                            }
                        }

                        if (closestEnemy) {
                            const dx = (closestEnemy.x + closestEnemy.width / 2) - (bullet.x + bullet.width / 2);
                            const dy = (closestEnemy.y + closestEnemy.height / 2) - (bullet.y + bullet.height / 2);
                            const angle = Math.atan2(dy, dx);

                            const homingStrength = 0.05;
                            bullet.x += Math.cos(angle) * currentBulletSpeed * homingStrength;
                            bullet.y += Math.sin(angle) * currentBulletSpeed * homingStrength - currentBulletSpeed * (1 - homingStrength);
                        } else {
                            bullet.y -= currentBulletSpeed;
                        }
                    } else {
                        bullet.y -= currentBulletSpeed;
                    }

                    if (bullet.y < 0) {
                        bullets.splice(i, 1);
                    }
                }
            }
        }

        function createExplosionParticles(x, y, baseColor, count) {
            if (!gameSettings.particles) return;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const size = Math.random() * 4 + 1;
                const lifetime = Math.random() * 60 + 30;

                const r = parseInt(baseColor.substring(1, 3), 16);
                const g = parseInt(baseColor.substring(3, 5), 16);
                const b = parseInt(baseColor.substring(5, 7), 16);
                const colorVariation = 30;
                const newR = Math.min(255, Math.max(0, r + (Math.random() - 0.5) * colorVariation));
                const newG = Math.min(255, Math.max(0, g + (Math.random() - 0.5) * colorVariation));
                const newB = Math.min(255, Math.max(0, b + (Math.random() - 0.5) * colorVariation));
                const finalColor = `rgb(${newR}, ${newG}, ${newB})`;

                particles.push({ x, y, size, color: finalColor, vx, vy, alpha: 1, lifetime, life: lifetime });
            }
        }

        function createExplosion(x, y) {
            const orbSize = 40;
            const orbLifetime = 60;
            const orbDamage = 1 * player.explosionDamageMultiplier; // Apply explosion damage multiplier

            explosionOrbs.push({
                x: x - orbSize / 2,
                y: y - orbSize / 2,
                width: orbSize,
                height: orbSize,
                color: '#FFFF00',
                damage: orbDamage,
                lifetime: orbLifetime,
                hitEnemies: new Set()
            });
            if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("0.5", "8n");
            createExplosionParticles(x, y, '#ff8800', 30);
        }


        function drawExplosionOrbs() {
            explosionOrbs.forEach(orb => {
                ctx.save();
                ctx.globalAlpha = orb.lifetime / 60; // Assuming orbLifetime was 60
                ctx.fillStyle = orb.color;
                ctx.fillRect(orb.x, orb.y, orb.width, orb.height);
                ctx.restore();
            });
        }

        function updateExplosionOrbs() {
            for (let i = explosionOrbs.length - 1; i >= 0; i--) {
                const orb = explosionOrbs[i];
                orb.lifetime--;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(orb, enemy) && !orb.hitEnemies.has(enemy)) {
                        enemy.health -= orb.damage;
                        orb.hitEnemies.add(enemy);
                        if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                            hitSynth.triggerAttackRelease("G4", "16n");
                            lastHitSoundTime = Date.now();
                        }
                        if (enemy.health <= 0) {
                            createBonus(enemy.x, enemy.y);
                            createExplosionParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 20);
                            if (player.hasExplodingBullets) {
                                createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            }
                            enemies.splice(j, 1);
                            if (gameMode !== 'endless') {
                                playerPounds += Math.round(enemyTypes[enemy.type].value * player.poundsMultiplier); // Apply pounds multiplier
                            }
                            if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("0.5", "8n");
                        }
                    }
                }

                if (boss.exists && checkCollision(orb, boss) && !orb.hitEnemies.has(boss)) {
                    boss.health -= orb.damage;
                    orb.hitEnemies.add(boss);
                    if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                        hitSynth.triggerAttackRelease("A4", "16n");
                        lastHitSoundTime = Date.now();
                    }
                    if (boss.health <= 0) {
                        handleBossDefeat();
                    }
                }

                if (orb.lifetime <= 0) {
                    explosionOrbs.splice(i, 1);
                }
            }
        }

        function spawnEnemy(levelConfig) {
            let type = 'NORMAL';
            const rand = Math.random();

            if (gameMode === 'level') {
                const enemyChances = [
                    { type: 'SHOOTER', chance: levelConfig.shooterEnemyChance },
                    { type: 'HEAVY', chance: levelConfig.heavyEnemyChance },
                    { type: 'DODGER', chance: levelConfig.dodgerEnemyChance },
                    { type: 'ARMORED', chance: levelConfig.armoredEnemyChance }
                ];

                let cumulativeChance = 0;
                for (const enemyChance of enemyChances) {
                    cumulativeChance += enemyChance.chance;
                    if (rand < cumulativeChance) {
                        type = enemyChance.type;
                        break;
                    }
                }
                if (type === 'NORMAL' && rand >= cumulativeChance) {
                    type = 'NORMAL';
                }

            } else {
                if (rand < 0.15) {
                    type = 'SHOOTER';
                } else if (rand < 0.30) {
                    type = 'HEAVY';
                } else if (rand < 0.45) {
                    type = 'DODGER';
                } else if (rand < 0.55) {
                    type = 'ARMORED';
                } else {
                    type = 'NORMAL';
                }
            }

            const enemyProps = enemyTypes[type];
            enemies.push({
                x: Math.random() * (CANVAS_WIDTH - 30), // enemyWidth
                y: 0,
                width: 30,
                height: 30,
                color: enemyProps.color,
                type: type,
                health: enemyProps.health,
                canShoot: enemyProps.canShoot,
                shootCooldown: enemyProps.shootCooldown,
                lastShotTime: Date.now(),
                speed: enemyProps.speed
            });
        }

        function spawnBossMinions(numMinions, minionType = 'BOSS_MINION') {
            showMessage('The Boss summons allies!', true, 1500);

            for (let i = 0; i < numMinions; i++) {
                const minionX = boss.x + boss.width / (numMinions + 1) * (i + 1) - 30 / 2; // enemyWidth
                const minionY = boss.y + boss.height + 10;
                const enemyProps = enemyTypes[minionType];

                enemies.push({
                    x: minionX,
                    y: minionY,
                    width: 30,
                    height: 30,
                    color: enemyProps.color,
                    type: minionType,
                    health: enemyProps.health,
                    canShoot: enemyProps.canShoot,
                    shootCooldown: enemyProps.shootCooldown,
                    lastShotTime: Date.now() + i * 200,
                    speed: enemyProps.speed
                });
            }
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                if ((enemy.type === 'HEAVY' || enemy.type === 'BOSS_MINION' || enemy.type === 'ARMORED') && enemy.health > 0) {
                    ctx.fillStyle = 'red';
                    const healthBarWidth = enemy.width * (enemy.health / enemyTypes[enemy.type].health);
                    ctx.fillRect(enemy.x, enemy.y - 5, healthBarWidth, 3);
                }
            });
        }

        function endGame(message) {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (epsilonDollarIntervalId) {
                clearInterval(epsilonDollarIntervalId);
                epsilonDollarIntervalId = null;
            }
            uiState = 'gameOver';
            showMessage(message, false, 0); // Display message indefinitely
            saveProgress();
            showScreen(uiState); // Update UI to show game over buttons
        }

        function updateEnemies() {
            const currentLevelConfig = levels[currentLevelIndex];
            const currentTime = Date.now();

            if (gameMode === 'level') {
                const maxEnemiesToSpawnForLevel = currentLevelConfig.enemyCount;
                const levelIsBossFight = currentLevelConfig.bossLevel;

                if (!levelIsBossFight) {
                    if (enemies.length < maxEnemiesToSpawnForLevel &&
                        (currentTime - lastEnemySpawnTime > currentLevelConfig.enemySpawnInterval)) {
                        spawnEnemy(currentLevelConfig);
                        lastEnemySpawnTime = currentTime;
                    } else if (enemies.length === 0 && !levelCompletionHandled) {
                        handleLevelCompletion();
                    }
                }
            } else { // Endless Mode
                if (!boss.exists) {
                    let dynamicSpawnInterval = Math.max(350, 1800 - (playerPounds / 50) - (playerEpsilonDollars / 25));
                    if (currentTime - lastEnemySpawnTime > dynamicSpawnInterval) {
                        spawnEnemy(currentLevelConfig); // Use current level config for endless mode enemy properties
                        lastEnemySpawnTime = currentTime;
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Apply enemy slow if active
                const currentEnemySpeed = player.enemySlowActive ? enemy.speed * 0.8 : enemy.speed; // 20% slow
                enemy.y += currentEnemySpeed;

                if (enemy.canShoot && currentTime - enemy.lastShotTime > enemy.shootCooldown) {
                    shootEnemyBullet(enemy);
                    enemy.lastShotTime = currentTime;
                }

                if (enemy.y > CANVAS_HEIGHT) {
                    enemies.splice(i, 1);
                    if (!boss.exists || gameMode === 'endless' || enemy.type === 'BOSS_MINION') {
                        playerHealth -= 1;
                        if (playerHealth <= 0) {
                            if (gameSettings.particles) createExplosionParticles(player.x + player.width / 2, player.y + player.height / 2, player.color, 50);
                            endGame('Game Over! You ran out of health.');
                        }
                        if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                            hitSynth.triggerAttackRelease("C2", "8n");
                            lastHitSoundTime = Date.now();
                        }
                    }
                }
            }
        }


        function shootEnemyBullet(shooter, bulletDirectionY = 1, bulletSpeedOverride = 3, targetPlayer = false) {
            const enemyBulletWidth = 6;
            const enemyBulletHeight = 6;
            const enemyBulletColor = '#00ffff';

            let vx = 0;
            let vy = bulletDirectionY * bulletSpeedOverride;

            if (targetPlayer) {
                const targetX = player.x + player.width / 2;
                const targetY = player.y + player.height / 2;
                const dx = targetX - (shooter.x + shooter.width / 2);
                const dy = targetY - (shooter.y + shooter.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    vx = (dx / distance) * bulletSpeedOverride;
                    vy = (dy / distance) * bulletSpeedOverride;
                }
            }

            enemyBullets.push({
                x: shooter.x + shooter.width / 2 - enemyBulletWidth / 2,
                y: shooter.y + (bulletDirectionY > 0 ? shooter.height : -enemyBulletHeight),
                width: enemyBulletWidth,
                height: enemyBulletHeight,
                color: enemyBulletColor,
                vx: vx,
                vy: vy
            });
        }

        function drawEnemyBullets() {
            enemyBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.vx || 0;
                bullet.y += bullet.vy || 3; // enemyBulletSpeed
                if (bullet.y > CANVAS_HEIGHT || bullet.y < 0 || bullet.x < 0 || bullet.x > CANVAS_WIDTH) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function handleBossDefeat() {
            if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("1", "4n");
            createExplosionParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.color, 100);

            if (gameMode === 'endless') {
                playerPounds += 500;
                showMessage('BOSS DEFEATED! SPEED UPGRADE!', false, 3000);
                player.baseSpeed += 1;
                saveProgress();
            } else if (gameMode === 'level' && levels[currentLevelIndex].bossLevel) {
                handleLevelCompletion();
            }
            boss.exists = false;
        }

        function spawnBoss() {
            if (!boss.exists) {
                boss.exists = true;
                // Use the config for the current level's boss
                const currentBossConfig = levels[currentLevelIndex].bossSpecifics;

                boss.maxHealth = currentBossConfig.health;
                boss.health = boss.maxHealth;
                boss.speed = currentBossConfig.movementSpeed;
                boss.shootCooldownSpread = currentBossConfig.spreadShotInterval;
                boss.shootCooldownTracking = currentBossConfig.trackingShotInterval;
                boss.bulletSpeedOverride = currentBossConfig.bulletSpeed;
                boss.width = 100;
                boss.height = 100;
                boss.minionsToSummon = currentBossConfig.minionsToSummon || 0;
                boss.minionSummonThresholds = currentBossConfig.minionSummonThresholds || [];
                boss.summonedMinionsAtThreshold = new Array(boss.minionSummonThresholds.length).fill(false);

                boss.x = CANVAS_WIDTH / 2 - boss.width / 2;
                boss.y = 50;
                boss.direction = Math.random() < 0.5 ? 1 : -1;
                boss.lastShotTimeSpread = Date.now();
                boss.lastShotTimeTracking = Date.now();

                showMessage(`BOSS ALERT! ${levels[currentLevelIndex].name}!`, false, 2000);
            }
        }

        function drawBoss() {
            if (boss.exists) {
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            }
        }

        function updateBoss() {
            if (boss.exists) {
                boss.x += boss.speed * boss.direction;
                if (boss.x <= 0 || boss.x >= CANVAS_WIDTH - boss.width) {
                    boss.direction *= -1;
                }

                const currentTime = Date.now();

                if (currentTime - boss.lastShotTimeSpread > boss.shootCooldownSpread) {
                    const numBullets = 3;
                    const spreadAngleDegrees = 20;
                    const startAngleDegrees = -spreadAngleDegrees / 2;

                    for (let i = 0; i < numBullets; i++) {
                        const angleDegrees = startAngleDegrees + (spreadAngleDegrees / (numBullets - 1)) * i;
                        const angleRadians = angleDegrees * (Math.PI / 180) + Math.PI / 2;

                        const vx = Math.cos(angleRadians) * boss.bulletSpeedOverride;
                        const vy = Math.sin(angleRadians) * boss.bulletSpeedOverride;

                        shootEnemyBullet(
                            { x: boss.x, y: boss.y, width: boss.width, height: boss.height },
                            1, boss.bulletSpeedOverride, false, vx, vy
                        );
                    }
                    boss.lastShotTimeSpread = currentTime;
                }

                if (currentTime - boss.lastShotTimeTracking > boss.shootCooldownTracking) {
                    shootEnemyBullet(
                        { x: boss.x, y: boss.y, width: boss.width, height: boss.height },
                        1, boss.bulletSpeedOverride * 1.5, true
                    );
                    boss.lastShotTimeTracking = currentTime;
                }

                if (gameMode === 'level' && levels[currentLevelIndex].bossLevel && boss.minionSummonThresholds.length > 0) {
                    const currentHealthPercentage = boss.health / boss.maxHealth;
                    boss.minionSummonThresholds.forEach((threshold, index) => {
                        if (currentHealthPercentage <= threshold && !boss.summonedMinionsAtThreshold[index]) {
                            spawnBossMinions(boss.minionsToSummon);
                            boss.summonedMinionsAtThreshold[index] = true;
                        }
                    });
                }
            }
        }

        function createBonus(x, y) {
            // enemyDropBonusChance is now a mutable global
            if (Math.random() < enemyDropBonusChance) {
                const types = Object.keys(bonusTypes);
                const randomType = types[Math.floor(Math.random() * types.length)];
                bonuses.push({
                    x: x,
                    y: y,
                    width: 20, // bonusWidth
                    height: 20, // bonusHeight
                    type: randomType,
                    color: bonusTypes[randomType].color,
                    label: bonusTypes[randomType].label
                });
            }
        }

        function drawBonuses() {
            bonuses.forEach(bonus => {
                ctx.fillStyle = bonus.color;
                ctx.fillRect(bonus.x, bonus.y, bonus.width, bonus.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(bonus.label, bonus.x + bonus.width / 2, bonus.y + bonus.height / 2);
            });
        }

        function updateBonuses() {
            const bonusSpeed = 2;
            for (let i = bonuses.length - 1; i >= 0; i--) {
                bonuses[i].y += bonusSpeed;
                if (bonuses[i].y > CANVAS_HEIGHT) {
                    bonuses.splice(i, 1);
                }
            }
        }

        function applyBonusEffect(bonusType) {
            const currentTime = Date.now();
            switch (bonusType) {
                case 'HEALTH':
                    playerHealth = Math.min(playerHealth + 1, playerMaxHealth + 2); // Cap at max health + 2 for temporary overheal
                    showMessage('Health Boost!', false, 1000);
                    break;
                case 'COOLDOWN':
                    cooldownEffectEndTime = currentTime + 7000; // cooldownReductionDuration
                    showMessage('Rapid Fire!', false, 1000);
                    break;
                case 'MULTISHOT':
                    multiShotCount = multiShotCount < 4 ? multiShotCount + 1 : 4;
                    multiShotEffectEndTime = currentTime + 5000; // multiShotDuration
                    showMessage(`${multiShotCount}x Shot!`, true, 1000);
                    break;
            }
        }

        function checkPowerUpExpirations() {
            const currentTime = Date.now();
            if (multiShotEffectEndTime > 0 && currentTime > multiShotEffectEndTime) {
                multiShotCount = 1;
                multiShotEffectEndTime = 0;
                showMessage('Multi-shot expired!', true, 1000);
            }
            if (cooldownEffectEndTime > 0 && currentTime > cooldownEffectEndTime) {
                cooldownEffectEndTime = 0;
                showMessage('Rapid Fire expired!', true, 1000);
            }

            // Shield cooldown check
            if (player.hasShield && !player.shieldActive && currentTime - player.lastShieldUsedTime > player.shieldCooldown) {
                player.shieldActive = true;
                showMessage('Shield Ready!', true, 1000);
            }
        }

        function handleCollisions() {
            // Player bullets vs. Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                if (bullet.isBeam) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (checkCollision(bullet, enemy)) {
                            enemy.health -= bullet.damage;
                            if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                                hitSynth.triggerAttackRelease("G4", "32n");
                                lastHitSoundTime = Date.now();
                            }
                            if (enemy.health <= 0) {
                                createBonus(enemy.x, enemy.y);
                                createExplosionParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 20);
                                if (player.hasExplodingBullets) {
                                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                }
                                enemies.splice(j, 1);
                                if (gameMode !== 'endless') {
                                    playerPounds += Math.round(enemyTypes[enemy.type].value * player.poundsMultiplier);
                                }
                                if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("0.5", "8n");
                            }
                        }
                    }
                } else {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (checkCollision(bullet, enemy)) {
                            enemy.health -= bullet.damage;
                            if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                                hitSynth.triggerAttackRelease("G4", "16n");
                                lastHitSoundTime = Date.now();
                            }
                            if (enemy.health <= 0) {
                                createBonus(enemy.x, enemy.y);
                                createExplosionParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 20);
                                if (player.hasExplodingBullets) {
                                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                }
                                enemies.splice(j, 1);
                                if (gameMode !== 'endless') {
                                    playerPounds += Math.round(enemyTypes[enemy.type].value * player.poundsMultiplier);
                                }
                                if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("0.5", "8n");
                            }

                            if (bullet.piercedCount > 0) {
                                bullet.piercedCount--;
                            } else {
                                bullets.splice(i, 1);
                                break;
                            }
                        }
                    }
                }

                // Player bullets vs. Boss
                if (boss.exists && checkCollision(bullet, boss)) {
                    boss.health -= bullet.damage;
                    if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                        hitSynth.triggerAttackRelease("A4", "16n");
                        lastHitSoundTime = Date.now();
                    }
                    if (boss.health <= 0) {
                        handleBossDefeat();
                    }
                    if (!bullet.isBeam) { // Beam bullets continue to hit
                        bullets.splice(i, 1);
                    }
                }
            }

            // Enemies vs. Player
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (checkCollision(player, enemies[i])) {
                    enemies.splice(i, 1);
                    if (player.hasShield && player.shieldActive) {
                        player.shieldActive = false;
                        player.lastShieldUsedTime = Date.now();
                        showMessage('Shield Activated!', true, 1000);
                        if (gameSettings.volume > -39) hitSynth.triggerAttackRelease("C5", "16n"); // Shield sound
                    } else {
                        playerHealth -= 1;
                        if (playerHealth <= 0) {
                            if (gameSettings.particles) createExplosionParticles(player.x + player.width / 2, player.y + player.height / 2, player.color, 50);
                            endGame('Game Over! You were hit!');
                        }
                        if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                            hitSynth.triggerAttackRelease("C2", "8n");
                            lastHitSoundTime = Date.now();
                        }
                        if (gameSettings.volume > -39) explosionSynth.triggerAttackRelease("0.5", "8n");
                    }
                }
            }

            // Enemy bullets vs. Player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const enemyBullet = enemyBullets[i];
                if (checkCollision(player, enemyBullet)) {
                    enemyBullets.splice(i, 1);
                    if (player.hasShield && player.shieldActive) {
                        player.shieldActive = false;
                        player.lastShieldUsedTime = Date.now();
                        showMessage('Shield Activated!', true, 1000);
                        if (gameSettings.volume > -39) hitSynth.triggerAttackRelease("C5", "16n"); // Shield sound
                    } else {
                        playerHealth -= 1;
                        if (playerHealth <= 0) {
                            if (gameSettings.particles) createExplosionParticles(player.x + player.width / 2, player.y + player.height / 2, player.color, 50);
                            endGame('Game Over! You were hit!');
                        }
                        if (gameSettings.volume > -39 && Date.now() - lastHitSoundTime > hitSoundCooldown) {
                            hitSynth.triggerAttackRelease("C2", "8n");
                            lastHitSoundTime = Date.now();
                        }
                    }
                    break;
                }
            }

            // Bonuses vs. Player
            for (let i = bonuses.length - 1; i >= 0; i--) {
                if (checkCollision(player, bonuses[i])) {
                    applyBonusEffect(bonuses[i].type);
                    bonuses.splice(i, 1);
                    break;
                }
            }
        }


        function updateParticles() {
            if (!gameSettings.particles) {
                particles.length = 0; // Clear particles if disabled
                return;
            }

            const particleGravity = 0.05;

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                p.x += p.vx;
                p.y += p.vy;
                p.vy += particleGravity;

                p.life--;
                p.alpha = p.life / p.lifetime;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            if (!gameSettings.particles) return;
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                ctx.restore();
            }
        }


        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        function gameLoop() {
            if (uiState !== 'inGame' && uiState !== 'levelComplete' && uiState !== 'gameOver') {
                animationId = null;
                return;
            }

            clearCanvas();
            updatePlayer();
            updateBullets();
            updateEnemies();
            updateEnemyBullets();
            updateBonuses();
            updateBoss();
            updateExplosionOrbs();
            handleCollisions();
            checkPowerUpExpirations();
            updateParticles();

            drawPlayer();
            drawBullets();
            drawEnemies();
            drawEnemyBullets();
            drawBonuses();
            drawBoss();
            drawExplosionOrbs();
            drawParticles();
            
            updateUI(); // Update UI elements with latest game state

            if (gameMode === 'endless' && !boss.exists && Date.now() - lastBossSpawnAttemptTime > 60000) { // bossAttemptInterval
                lastBossSpawnAttemptTime = Date.now();
                if (Math.random() < 0.4) { // bossChancePerInterval
                    spawnBoss();
                }
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // --- Game State Management ---
        function resetGameState(fullReset = false) {
            bullets.length = 0;
            enemies.length = 0;
            enemyBullets.length = 0;
            bonuses.length = 0;
            particles.length = 0;
            explosionOrbs.length = 0;

            player.x = CANVAS_WIDTH / 2 - player.width / 2;
            
            if (fullReset) {
                playerPounds = 0;
                playerEpsilonDollars = 0;
                playerMaxHealth = initialPlayerMaxHealth;
                player.baseSpeed = player.initialBaseSpeed;
                player.baseBulletDamage = player.initialBaseBulletDamage;
                player.baseShootCooldown = player.initialBaseShootCooldown;
                player.hasPiercingShotLevel = player.initialPiercingShotLevel;
                equippedBulletMode = 'normal';
                player.hasBeamShot = false;
                player.hasExplodingBullets = false;
                player.hasHomingBullets = false;
                // Reset new player upgrade stats
                player.healthRegenAmount = 0;
                player.bulletSpeedMultiplier = 1.0;
                player.poundsMultiplier = 1.0;
                player.enemySlowActive = false;
                player.hasShield = false;
                player.shieldActive = false;
                player.lastShieldUsedTime = 0;
                player.explosionDamageMultiplier = 1.0;
                player.critChance = 0;
                enemyDropBonusChance = 0.3; // Reset global variable

                currentLevelIndex = 0;
                completedLevels = new Set();
                
                pShopItems.forEach(item => item.currentPurchases = item.initialValue);
                eShopItems.forEach(item => {
                    item.currentPurchases = item.initialValue;
                    if (item.isEquippable && item.unequippedEffect) {
                        item.unequippedEffect(); // Call unequip effect for all equippables
                    }
                });
            }

            playerHealth = playerMaxHealth;
            
            lastEnemySpawnTime = Date.now();
            canShoot = true;
            multiShotCount = 1;
            multiShotEffectEndTime = 0;
            cooldownEffectEndTime = 0;

            boss.exists = false;
            boss.health = 0;
            boss.maxHealth = 0;
            boss.x = 0;
            boss.y = 50;
            boss.direction = 1;
            boss.lastShotTimeSpread = 0;
            boss.lastShotTimeTracking = 0;
            boss.minionSummonThresholds = [];
            boss.summonedMinionsAtThreshold = [];
            boss.bulletSpeedOverride = 3;
            lastBossSpawnAttemptTime = Date.now();

            levelCompletionHandled = false;
        }

        function saveProgress() {
            try {
                const pShopItemsData = pShopItems.map(item => ({
                    id: item.id,
                    currentPurchases: item.currentPurchases
                }));
                const eShopItemsData = eShopItems.map(item => ({
                    id: item.id,
                    currentPurchases: item.currentPurchases
                }));

                const dataToSave = {
                    playerPounds: playerPounds,
                    playerEpsilonDollars: playerEpsilonDollars,
                    playerMaxHealth: playerMaxHealth,
                    playerBaseSpeed: player.baseSpeed,
                    playerBaseBulletDamage: player.baseBulletDamage,
                    playerBaseShootCooldown: player.baseShootCooldown,
                    
                    playerHasPiercingShotLevel: player.hasPiercingShotLevel,
                    equippedBulletMode: equippedBulletMode,

                    // Save new player upgrade stats
                    healthRegenAmount: player.healthRegenAmount,
                    bulletSpeedMultiplier: player.bulletSpeedMultiplier,
                    poundsMultiplier: player.poundsMultiplier,
                    enemySlowActive: player.enemySlowActive,
                    hasShield: player.hasShield,
                    shieldActive: player.shieldActive,
                    lastShieldUsedTime: player.lastShieldUsedTime,
                    explosionDamageMultiplier: player.explosionDamageMultiplier,
                    critChance: player.critChance,
                    enemyDropBonusChance: enemyDropBonusChance, // Save global variable

                    pShopItems: pShopItemsData,
                    eShopItems: eShopItemsData,
                    currentLevelIndex: currentLevelIndex,
                    completedLevels: Array.from(completedLevels),
                    gameSettings: gameSettings
                };

                localStorage.setItem('ltps2dShooterGameProgress', JSON.stringify(dataToSave));
                console.log("Game progress and settings saved to local storage!");
            } catch (error) {
                console.error("Error saving game progress to local storage:", error);
            }
        }

        function loadProgress() {
            console.log("Attempting to load game progress.");
            try {
                const savedData = localStorage.getItem('ltps2dShooterGameProgress');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    playerPounds = data.playerPounds || 0;
                    playerEpsilonDollars = data.playerEpsilonDollars || 0;
                    playerMaxHealth = data.playerMaxHealth || initialPlayerMaxHealth;
                    player.baseSpeed = data.playerBaseSpeed || player.initialBaseSpeed;
                    player.baseBulletDamage = data.playerBaseBulletDamage || player.initialBaseBulletDamage;
                    player.baseShootCooldown = data.playerBaseShootCooldown || player.initialBaseShootCooldown;
                    player.hasPiercingShotLevel = data.playerHasPiercingShotLevel || player.initialPiercingShotLevel;
                    equippedBulletMode = data.equippedBulletMode || 'normal';

                    // Load new player upgrade stats
                    player.healthRegenAmount = data.healthRegenAmount || 0;
                    player.bulletSpeedMultiplier = data.bulletSpeedMultiplier || 1.0;
                    player.poundsMultiplier = data.poundsMultiplier || 1.0;
                    player.enemySlowActive = data.enemySlowActive || false;
                    player.hasShield = data.hasShield || false;
                    player.shieldActive = data.shieldActive || false;
                    player.lastShieldUsedTime = data.lastShieldUsedTime || 0;
                    player.explosionDamageMultiplier = data.explosionDamageMultiplier || 1.0;
                    player.critChance = data.critChance || 0;
                    enemyDropBonusChance = data.enemyDropBonusChance || 0.3; // Load global variable


                    if (data.pShopItems) {
                        data.pShopItems.forEach(savedItem => {
                            const shopItem = pShopItems.find(item => item.id === savedItem.id);
                            if (shopItem) {
                                shopItem.currentPurchases = savedItem.currentPurchases;
                                // Re-apply effects of non-equippable upgrades
                                if (!shopItem.isEquippable && shopItem.effect && savedItem.currentPurchases > shopItem.initialValue) {
                                     // For max health, we don't re-apply, as playerMaxHealth is directly loaded
                                     // For other effects, re-apply for each purchase
                                    for(let i = 0; i < savedItem.currentPurchases - shopItem.initialValue; i++) {
                                        if (shopItem.id !== 'max_health_upgrade') { // Max health is handled by direct load
                                            shopItem.effect();
                                        }
                                    }
                                }
                            }
                        });
                    }
                    if (data.eShopItems) {
                        data.eShopItems.forEach(savedItem => {
                            const shopItem = eShopItems.find(item => item.id === savedItem.id);
                            if (shopItem) {
                                shopItem.currentPurchases = savedItem.currentPurchases;
                                // Re-apply effects for non-equippable E$ items
                                if (!shopItem.isEquippable && shopItem.effect && savedItem.currentPurchases > shopItem.initialValue) {
                                    for(let i = 0; i < savedItem.currentPurchases - shopItem.initialValue; i++) {
                                        shopItem.effect();
                                    }
                                }
                            }
                        });
                    }
                    
                    currentLevelIndex = data.currentLevelIndex || 0;
                    completedLevels = new Set(data.completedLevels || []);

                    gameSettings = {
                        volume: data.gameSettings?.volume !== undefined ? data.gameSettings.volume : -10,
                        particles: data.gameSettings?.particles !== undefined ? data.gameSettings.particles : true
                    };
                    
                    // Apply equipped bullet mode effect immediately after loading
                    const equippedItem = eShopItems.find(item => item.id === (data.equippedBulletMode || 'normal') && item.isEquippable);
                    if (equippedItem && equippedItem.equippedEffect) {
                        equippedItem.equippedEffect();
                    }

                    playerHealth = data.playerHealth || data.playerMaxHealth || initialPlayerMaxHealth;

                    console.log("Game progress and settings loaded from local storage!");
                } else {
                    console.log("No saved data found in local storage. Starting new game.");
                    resetGameState(true);
                }
            } catch (error) {
                console.error("Error loading game progress from local storage:", error);
                showMessage('Error loading progress. Starting new game.', true);
                resetGameState(true);
            } finally {
                console.log("Calling showMainMenu()");
                showMainMenu();
            }
        }


        // --- UI State Transitions ---
        function showScreen(screenId) {
            // Hide all screens first
            document.querySelectorAll('.shop-screen, #mainMenuButtons, #inGameButtons, #gameCanvas, #levelMapContainer').forEach(el => {
                el.style.display = 'none';
            });
            levelDisplay.style.display = 'none';
            bossHealthContainer.style.display = 'none';
            
            // Show the requested screen
            switch (screenId) {
                case 'mainMenu':
                    mainMenuButtons.style.display = 'flex';
                    canvas.style.display = 'none'; // Ensure canvas is hidden in main menu
                    levelDisplay.style.display = 'none';
                    break;
                case 'levelSelect':
                    mainMenuButtons.style.display = 'none';
                    levelMapContainer.style.display = 'flex';
                    levelDisplay.style.display = 'block'; // Show level display for level select
                    break;
                case 'inGame':
                    canvas.style.display = 'block';
                    inGameButtons.style.display = 'flex';
                    nextLevelBtn.style.display = 'none';
                    resetGameBtn.style.display = 'block';
                    returnToMenuBtn.style.display = 'block';
                    levelDisplay.style.display = 'block';
                    break;
                case 'levelComplete':
                    canvas.style.display = 'block';
                    inGameButtons.style.display = 'flex';
                    // Show Next Level button only if there's a next level
                    if (currentLevelIndex < levels.length - 1) {
                        nextLevelBtn.style.display = 'block';
                    } else {
                        nextLevelBtn.style.display = 'none';
                    }
                    resetGameBtn.style.display = 'block';
                    returnToMenuBtn.style.display = 'block';
                    levelDisplay.style.display = 'block';
                    break;
                case 'gameOver':
                    canvas.style.display = 'block';
                    inGameButtons.style.display = 'flex';
                    nextLevelBtn.style.display = 'none'; // No next level after game over
                    resetGameBtn.style.display = 'block';
                    returnToMenuBtn.style.display = 'block';
                    levelDisplay.style.display = 'block';
                    break;
                case 'pShop':
                    pShopScreen.style.display = 'flex';
                    renderShopItems('P$');
                    break;
                case 'eShop':
                    eShopScreen.style.display = 'flex';
                    renderShopItems('E$');
                    break;
                case 'settings':
                    settingsScreen.style.display = 'flex';
                    updateSettingsDisplay();
                    break;
                case 'resetConfirm':
                    resetConfirmationPanel.style.display = 'flex';
                    break;
            }
            updateUI(); // Always update UI after screen change
            checkAndSetMobileControlsVisibility();
        }

        function showMainMenu() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (epsilonDollarIntervalId) {
                clearInterval(epsilonDollarIntervalId);
                epsilonDollarIntervalId = null;
            }
            gameMode = null;
            uiState = 'mainMenu';
            clearCanvas();
            saveProgress();
            showScreen('mainMenu');
        }

        function setupLevelMode() {
            gameMode = 'level';
            resetGameState(false);
            playerHealth = playerMaxHealth;
            uiState = 'levelSelect';
            clearCanvas();
            renderLevelMap(true); // Enable clicks for level selection
            showScreen('levelSelect');
        }

        function setupEndlessMode() {
            gameMode = 'endless';
            resetGameState(false);
            startGameInMode();
        }

        function startGameInMode() {
            uiState = 'inGame';
            // Start audio context on user interaction
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            animationId = requestAnimationFrame(gameLoop);
            if (gameMode === 'endless') {
                if (epsilonDollarIntervalId) clearInterval(epsilonDollarIntervalId);
                epsilonDollarIntervalId = setInterval(() => {
                    if (uiState === 'inGame' && gameMode === 'endless') {
                        playerEpsilonDollars += 10;
                        saveProgress();
                    }
                    updateUI(); // Update E$ display
                }, 35000); // 10 E$ every 35 seconds
                lastBossSpawnAttemptTime = Date.now();
            }
            showScreen('inGame');
            showMessage('Game Start!', false, 1500);
        }

        function loadLevel(levelIdx) {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            clearCanvas();
            resetGameState(false);
            
            playerHealth = playerMaxHealth; // Ensure health is full on level restart/load
            currentLevelIndex = levelIdx;
            
            const levelConfig = levels[levelIdx];

            uiState = 'inGame';

            const messageText = levelConfig.message || `Level ${levelIdx + 1}: ${levelConfig.name}`;
            showMessage(messageText, messageText.length > 50, Math.min(4000, messageText.length * 50 + 1000));

            if (levelConfig.bossLevel) {
                setTimeout(() => {
                    if (uiState === 'inGame') spawnBoss();
                }, 1000);
            }

            // Start audio context on user interaction
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            animationId = requestAnimationFrame(gameLoop);
            showScreen('inGame'); // Ensure inGame UI is shown
        }

        function handleLevelCompletion() {
            if (levelCompletionHandled) return;
            levelCompletionHandled = true;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (epsilonDollarIntervalId) {
                clearInterval(epsilonDollarIntervalId);
                epsilonDollarIntervalId = null;
            }
            clearCanvas();

            completedLevels.add(currentLevelIndex);
            
            const nextLevelExists = currentLevelIndex < levels.length - 1;

            uiState = 'levelComplete';
            
            if (nextLevelExists) {
                currentLevelIndex++;
                showMessage(`Level ${currentLevelIndex} Complete! Get Ready for Level ${currentLevelIndex + 1}!`, false, 0);
            } else {
                showMessage('Congratulations! You completed all levels! Game Won!', false, 0);
            }
            saveProgress();
            showScreen('levelComplete'); // Update UI to show level complete buttons
        }


        // --- Shop and Upgrade Logic ---
        function purchaseItem(itemId, shopType) {
            const itemsList = shopType === 'P$' ? pShopItems : eShopItems;
            const item = itemsList.find(i => i.id === itemId);

            if (!item) return false;

            const maxedOut = item.currentPurchases >= item.maxPurchases;
            let canAfford = false;
            let currencyType = item.currency || 'P$';

            if (currencyType === 'P$') {
                canAfford = playerPounds >= item.cost;
            } else if (currencyType === 'E$') {
                canAfford = playerEpsilonDollars >= item.cost;
            }

            let requirementsMet = true;
            if (item.requires) {
                item.requires.forEach(req => {
                    const allShopItems = [...pShopItems, ...eShopItems];
                    const requiredItem = allShopItems.find(i => i.id === req.id);
                    if (!requiredItem || requiredItem.currentPurchases < req.purchased) {
                        requirementsMet = false;
                    }
                });
            }

            if (canAfford && !maxedOut && requirementsMet) {
                if (currencyType === 'P$') {
                    playerPounds -= item.cost;
                } else {
                    playerEpsilonDollars -= item.cost;
                }
                if (!item.isEquippable && item.effect) {
                    item.effect();
                }
                item.currentPurchases++;
                showMessage(`${item.name} Purchased!`, true);
                saveProgress();
                updateUI(); // Update currency display
                renderShopItems(shopType); // Re-render shop to update item states
                return true;
            } else if (maxedOut) {
                showMessage(`${item.name} is Maxed Out!`, true);
            } else if (!requirementsMet) {
                showMessage(`Requirements not met for ${item.name}!`, true);
            } else {
                showMessage(`Not enough ${currencyType} for ${item.name}!`, true);
            }
            return false;
        }

        function equipBulletMode(modeId) {
            const currentEquippedItem = eShopItems.find(item => item.id === equippedBulletMode && item.isEquippable);
            if (currentEquippedItem && currentEquippedItem.unequippedEffect) {
                currentEquippedItem.unequippedEffect();
            }

            const newItemToEquip = eShopItems.find(item => item.id === modeId && item.isEquippable);
            if (newItemToEquip && newItemToEquip.equippedEffect) {
                newItemToEquip.equippedEffect();
                equippedBulletMode = modeId;
                showMessage(`${newItemToEquip.name} Equipped!`, true);
            } else {
                equippedBulletMode = 'normal';
                player.hasBeamShot = false;
                player.hasExplodingBullets = false;
                player.hasHomingBullets = false;
                player.enemySlowActive = false; // Reset if unequipped
                player.hasShield = false; // Reset if unequipped
                player.shieldActive = false; // Reset if unequipped
                showMessage(`Equipped Normal Bullets!`, true);
            }
            saveProgress();
            updateUI(); // Update equipped bullet display
            renderShopItems('E$'); // Re-render E$ shop to update equip status
        }

        // --- Settings Logic ---
        function updateVolumeFromSlider() {
            const newVolume = parseFloat(volumeSlider.value);
            gameSettings.volume = newVolume;
            if (Tone.Master) {
                Tone.Master.volume.value = newVolume;
            }
            saveProgress();
            updateSettingsDisplay(); // Update button text
        }

        function toggleVolume() {
            // If current volume is effectively muted, unmute to the last saved volume or default -10
            const newVolume = gameSettings.volume <= -39 ? (localStorage.getItem('savedVolume') ? parseFloat(localStorage.getItem('savedVolume')) : -10) : -40;
            
            if (gameSettings.volume > -39) { // If muting, save the current volume before setting to -40
                 localStorage.setItem('savedVolume', gameSettings.volume.toString());
            } else { // If unmuting, clear the saved volume as it will be restored from gameSettings.volume later
                localStorage.removeItem('savedVolume');
            }

            gameSettings.volume = newVolume;
            if (Tone.Master) {
                Tone.Master.volume.value = newVolume;
            }
            showMessage(`Volume: ${newVolume > -39 ? 'ON' : 'OFF'}`, true);
            saveProgress();
            updateSettingsDisplay(); // Update button text
        }

        function toggleParticles() {
            gameSettings.particles = !gameSettings.particles;
            showMessage(`Particles: ${gameSettings.particles ? 'ON' : 'OFF'}`, true);
            saveProgress();
            updateSettingsDisplay(); // Update button text
        }

        function resetAllGameData() {
            localStorage.clear();
            resetGameState(true);
            saveProgress(); // Save the cleared state
            showMainMenu();
            showMessage('All game data has been reset!', true, 2000);
        }

        function resetLevelProgress() {
            currentLevelIndex = 0;
            completedLevels = new Set();
            saveProgress();
            uiState = 'levelSelect';
            renderLevelMap(true);
            showScreen('levelSelect');
            showMessage('Level progress reset!', true, 2000);
        }

        function resetUpgrades() {
            pShopItems.forEach(item => item.currentPurchases = item.initialValue);
            eShopItems.forEach(item => {
                item.currentPurchases = item.initialValue;
                if (item.isEquippable && item.unequippedEffect) {
                    item.unequippedEffect(); // Call unequip effect
                }
            });

            playerMaxHealth = initialPlayerMaxHealth;
            player.baseSpeed = player.initialBaseSpeed;
            player.baseBulletDamage = player.initialBaseBulletDamage;
            player.baseShootCooldown = player.initialBaseShootCooldown;
            player.hasPiercingShotLevel = player.initialPiercingShotLevel;
            equippedBulletMode = 'normal';
            player.hasBeamShot = false;
            player.hasExplodingBullets = false;
            player.hasHomingBullets = false;
            // Reset new player upgrade stats
            player.healthRegenAmount = 0;
            player.bulletSpeedMultiplier = 1.0;
            player.poundsMultiplier = 1.0;
            player.enemySlowActive = false;
            player.hasShield = false;
            player.shieldActive = false;
            player.lastShieldUsedTime = 0;
            player.explosionDamageMultiplier = 1.0;
            player.critChance = 0;
            enemyDropBonusChance = 0.3; // Reset global variable

            playerHealth = initialPlayerMaxHealth; // Reset health to initial max

            saveProgress();
            uiState = 'settings';
            showScreen('settings');
            showMessage('All upgrades reset!', true, 2000);
        }

        // --- UI Rendering Functions ---
        function renderLevelMap(enableClicks = false) {
            levelMapContainer.innerHTML = ''; // Clear previous map
            if (gameMode !== 'level' && !enableClicks) {
                levelMapContainer.style.display = 'none';
                return;
            }
            levelMapContainer.style.display = 'flex';

            levels.forEach((level, index) => {
                const levelNode = document.createElement('div');
                levelNode.classList.add('level-node');
                levelNode.textContent = index + 1;

                const isCompleted = completedLevels.has(index);
                const isCurrent = index === currentLevelIndex;
                const isLocked = !isCompleted && index > currentLevelIndex;

                if (isCompleted) {
                    levelNode.classList.add('completed');
                }
                if (isCurrent && (gameMode === 'level' || enableClicks)) {
                    levelNode.classList.add('current');
                }
                if (isLocked) {
                    levelNode.classList.add('locked');
                    levelNode.style.cursor = 'not-allowed';
                } else if (enableClicks) {
                    levelNode.style.cursor = 'pointer';
                    levelNode.onclick = () => loadLevel(index);
                }

                levelMapContainer.appendChild(levelNode);
            });
        }

        function renderShopItems(shopType) {
            const itemsToDisplay = shopType === 'P$' ? pShopItems : eShopItems;
            const container = shopType === 'P$' ? pShopItemsContainer : eShopItemsContainer;
            container.innerHTML = ''; // Clear previous items

            itemsToDisplay.forEach(item => {
                const shopItemDiv = document.createElement('div');
                shopItemDiv.classList.add('shop-item');
                if (item.currency === 'E$') {
                    shopItemDiv.classList.add('epsilon');
                }

                const maxedOut = item.currentPurchases >= item.maxPurchases;
                const owned = item.currentPurchases > 0;
                const canAffordP = (item.currency === 'P$' || !item.currency) ? (playerPounds >= item.cost) : false;
                const canAffordE = item.currency === 'E$' ? (playerEpsilonDollars >= item.cost) : false;
                const canAfford = canAffordP || canAffordE;

                let requirementsMet = true;
                if (item.requires) {
                    item.requires.forEach(req => {
                        const allShopItems = [...pShopItems, ...eShopItems];
                        const requiredItem = allShopItems.find(i => i.id === req.id);
                        if (!requiredItem || requiredItem.currentPurchases < req.purchased) {
                            requirementsMet = false;
                        }
                    });
                }

                const isDisabledBuy = (!canAfford || maxedOut || !requirementsMet);
                const buttonTextBuy = maxedOut ? 'MAXED' : (requirementsMet ? (canAfford ? 'BUY' : `NEED ${item.currency || 'P$'}`) : 'REQUIREMENTS NOT MET');
                const currencySymbol = item.currency === 'E$' ? 'E$' : 'P$';
                const isEquipped = equippedBulletMode === item.id;
                const isDisabledEquip = isEquipped;

                shopItemDiv.innerHTML = `
                    <h3>${item.name}</h3>
                    <p>${item.description}</p>
                    <p class="cost">Cost: ${currencySymbol}${item.cost}</p>
                    <p>Purchased: ${item.currentPurchases}/${item.maxPurchases}</p>
                    ${item.isEquippable ? `<p class="equip-status ${isEquipped ? '' : 'not-equipped'}">${isEquipped ? 'Currently Equipped' : 'Not Equipped'}</p>` : ''}
                `;

                const actionButton = document.createElement('button');
                if (item.isEquippable && owned) {
                    actionButton.textContent = isEquipped ? 'EQUIPPED' : 'EQUIP';
                    actionButton.classList.add('equip-button');
                    actionButton.disabled = isDisabledEquip;
                    actionButton.onclick = () => equipBulletMode(item.id);
                } else {
                    actionButton.textContent = buttonTextBuy;
                    actionButton.disabled = isDisabledBuy;
                    actionButton.onclick = () => purchaseItem(item.id, shopType);
                }
                shopItemDiv.appendChild(actionButton);
                container.appendChild(shopItemDiv);
            });
        }

        function updateSettingsDisplay() {
            volumeSlider.value = gameSettings.volume;
            toggleVolumeBtn.textContent = gameSettings.volume > -39 ? 'ON' : 'OFF';
            toggleVolumeBtn.classList.toggle('active-setting', gameSettings.volume > -39);
            toggleVolumeBtn.classList.toggle('inactive-setting', gameSettings.volume <= -39);

            toggleParticlesBtn.textContent = gameSettings.particles ? 'ON' : 'OFF';
            toggleParticlesBtn.classList.toggle('active-setting', gameSettings.particles);
            toggleParticlesBtn.classList.toggle('inactive-setting', !gameSettings.particles);
        }

        // --- Event Listeners ---
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize Tone.js synths
            playerShootSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0.05, release: 0.1 },
                volume: -10
            }).toDestination();

            hitSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05, octaves: 4, oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.8, attackCurve: 'exponential' },
                volume: -10
            }).toDestination();

            explosionSynth = new Tone.NoiseSynth({
                envelope: { attack: 0.005, decay: 0.2, sustain: 0.0, release: 0.3 },
                volume: -15
            }).toDestination();

            beamSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 0.8 },
                volume: -5
            }).toDestination();

            // Load saved progress and settings
            loadProgress();
            
            // Set initial master volume
            Tone.Master.volume.value = gameSettings.volume;

            // Update UI once after loading
            updateUI();

            // Set up main menu buttons initial state
            showScreen('mainMenu');
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
            }

            if (e.key.length === 1 || e.key === '-') {
                let secretCodeBuffer = localStorage.getItem('secretCodeBuffer') || '';
                secretCodeBuffer += e.key;
                const SECRET_CODE_LENGTH = SECRET_CODE_PREFIX.length;
                if (secretCodeBuffer.length > SECRET_CODE_LENGTH + 5) {
                    secretCodeBuffer = secretCodeBuffer.substring(secretCodeBuffer.length - (SECRET_CODE_LENGTH + 5));
                }
                localStorage.setItem('secretCodeBuffer', secretCodeBuffer);

                if (secretCodeBuffer.includes(SECRET_CODE_PREFIX)) {
                    playerPounds += 10000;
                    playerEpsilonDollars += 10000;
                    showMessage('Secret Code Activated! Resources Granted!', true, 2000);
                    localStorage.removeItem('secretCodeBuffer'); // Clear buffer after activation
                    saveProgress();
                    updateUI(); // Update resource displays
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
            }
        });

        // Mobile controls event listeners
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowLeft = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowLeft = false; });
        shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.Space = true; });
        shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.Space = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowRight = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowRight = false; });

        // Function to check screen size and show/hide mobile controls
        function checkAndSetMobileControlsVisibility() {
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (mobileControls) {
                if (isMobile && (uiState === 'inGame' || uiState === 'levelComplete' || uiState === 'gameOver')) {
                    mobileControls.style.display = 'flex';
                } else {
                    mobileControls.style.display = 'none';
                }
            }
            // Reset keys if not on mobile, to prevent stuck movement
            if (!isMobile) {
                keys.ArrowLeft = false;
                keys.ArrowRight = false;
                keys.Space = false;
            }
        }

        // Listen for window resize to adjust mobile controls visibility
        window.addEventListener('resize', checkAndSetMobileControlsVisibility);

        // --- Button Event Handlers ---
        levelModeBtn.addEventListener('click', () => {
            setupLevelMode();
            Tone.start(); // Start audio context on user interaction
        });
        endlessModeBtn.addEventListener('click', () => {
            setupEndlessMode();
            Tone.start(); // Start audio context on user interaction
        });
        pShopBtn.addEventListener('click', () => showScreen('pShop'));
        eShopBtn.addEventListener('click', () => showScreen('eShop'));
        settingsBtn.addEventListener('click', () => showScreen('settings'));
        backToMenuFromPShopBtn.addEventListener('click', showMainMenu);
        backToMenuFromEShopBtn.addEventListener('click', showMainMenu);
        backToMenuFromSettingsBtn.addEventListener('click', showMainMenu);
        nextLevelBtn.addEventListener('click', () => loadLevel(currentLevelIndex));
        resetGameBtn.addEventListener('click', () => {
            if (gameMode === 'level') {
                loadLevel(currentLevelIndex);
            } else if (gameMode === 'endless') {
                setupEndlessMode();
            }
        });
        returnToMenuBtn.addEventListener('click', showMainMenu);

        // Settings actions
        volumeSlider.addEventListener('input', updateVolumeFromSlider);
        toggleVolumeBtn.addEventListener('click', toggleVolume);
        toggleParticlesBtn.addEventListener('click', toggleParticles);
        resetGameDataBtn.addEventListener('click', () => showScreen('resetConfirm'));

        // Reset confirmation actions
        confirmResetAllDataBtn.addEventListener('click', resetAllGameData);
        confirmResetLevelProgressBtn.addEventListener('click', resetLevelProgress);
        confirmResetUpgradesBtn.addEventListener('click', resetUpgrades);
        cancelResetBtn.addEventListener('click', () => showScreen('settings'));

        // Initial call to hide unwanted screens and show main menu after loading
        showScreen('mainMenu'); // Set initial UI state
    </script>
</body>
</html>
